using UnityEngine;
using System;
using System.Collections.Generic;

namespace NDMFMerge.Runtime
{
    public enum BoneConflictResolution
    {
        [InspectorName("Force Merge (Snap)")]
        StillMerge,

        [InspectorName("Rename (Keep Separate)")]
        Rename,

        [InspectorName("Don't Merge (Delete/Ignore)")]
        DontMerge,

        [InspectorName("Merge Into Selected...")]
        MergeIntoSelected,

        [InspectorName("Constraint To Target (Safe)")]
        ConstraintToTarget
    }

    public enum BoundsFixMode
    {
        None = 0,
        CopyFromBody = 1,
        RecalculateFromMesh = 2
    }

    [Serializable]
    public class BoneNameMapping
    {
        [Tooltip("Source/outfit bone name (after prefix/suffix stripping).")]
        public string from;

        [Tooltip("Target/avatar bone name to map into.")]
        public string to;
    }

    [Serializable]
    public class OutfitToMerge
    {
        // Used by Editor for the foldout state
        public bool isExpanded = false;

        [Tooltip("The outfit/armature GameObject to merge")]
        public GameObject outfit;

        [Tooltip("Prefix to remove from bone names when matching")]
        public string prefix = "";

        [Tooltip("Suffix to remove from bone names when matching")]
        public string suffix = "";

        [Tooltip("Prefix to add to unique bones (bones that don't exist in avatar)")]
        public string uniqueBonePrefix = "";

        [Tooltip("Prefix to add to all mesh GameObjects")]
        public string meshPrefix = "";

        [Space(6)]
        [Tooltip("Merge this outfit's Animator into the target. Skips AAS autogenerated layers.")]
        [InspectorName("Merge Animator (Basic)")]
        public bool mergeAnimator = false;

        [Tooltip("Merge this outfit's Animator into the target INCLUDING AAS autogenerated layers.")]
        [InspectorName("Merge Animator (+AAS Layers)")]
        public bool mergeAnimatorIncludingAAS = false;

        // =======================
        // NEW PER-OUTFIT OPTIONS
        // =======================

        [Header("Per-Outfit Fixes")]

        [Tooltip("Fix SkinnedMeshRenderer bounds to prevent frustum culling issues.")]
        public BoundsFixMode boundsFixMode = BoundsFixMode.None;

        [Tooltip("Copy probeAnchor + probe settings from the body to outfit meshes so lighting matches.")]
        public bool syncAnchorOverrides = true;

        [Tooltip("Force outfit root scale to (1,1,1) before merging.")]
        public bool forceScaleToOne = false;

        [Tooltip("After merge, delete outfit bones that have no vertex weights and no child objects/components.")]
        public bool removeUnusedBones = false;

        [Header("Per-Outfit Bone Mapping")]

        [Tooltip("Optional extra bone mappings for this specific outfit.")]
        public List<BoneNameMapping> boneNameMappings = new List<BoneNameMapping>();
    }

    [Serializable]
    public class BoneConflictEntry
    {
        [HideInInspector]
        public string outfitName;

        [Tooltip("The bone on the Outfit")]
        public Transform sourceBone;

        [Tooltip("The bone on the Avatar it tried to match with")]
        public Transform targetBone;

        [Tooltip("How to resolve this specific conflict")]
        public BoneConflictResolution resolution = BoneConflictResolution.StillMerge;

        [Tooltip("Required if 'Merge Into Selected' is chosen")]
        public Transform customTargetBone;

        // Debug info
        public Vector3 positionDifference;
        public float rotationDifference;
        public Vector3 scaleDifference;
    }

    [Serializable]
    public class BrokenAnimatorReference
    {
        public string originalPath;
        public string suggestedPath;
        public UnityEngine.Object componentReference;
        public string fieldName;
        public bool autoFixed;
    }

    [ExecuteInEditMode]
    [AddComponentMenu("NDMF Merge/CVR Merge Armature")]
    [DisallowMultipleComponent]
    public class CVRMergeArmature : MonoBehaviour
    {
        [Header("Outfits to Merge")]
        public List<OutfitToMerge> outfitsToMerge = new List<OutfitToMerge>();

        [Header("Global Tolerance Settings")]
        [Tooltip("Position difference (meters) to consider a conflict.")]
        public float positionThreshold = 0.001f;

        [Tooltip("Rotation difference (degrees) to consider a conflict.")]
        public float rotationThreshold = 0.5f;

        [Tooltip("If true, scale differences will be flagged as conflicts.")]
        public bool detectScaleConflicts = true;

        [Tooltip("Scale difference (vector magnitude) to consider a conflict.")]
        public float scaleThreshold = 0.01f;

        [Header("Bone Conflict Resolution")]
        [Tooltip("Default resolution when a mismatch is detected.")]
        public BoneConflictResolution defaultBoneConflictResolution = BoneConflictResolution.StillMerge;

        [Tooltip("Per-bone conflict resolution (Populated via 'Detect Mismatches' button)")]
        public List<BoneConflictEntry> boneConflicts = new List<BoneConflictEntry>();

        [Header("Exclusions")]
        public List<Transform> excludedTransforms = new List<Transform>();
        public List<string> excludedNamePatterns = new List<string>();

        [Space(10)]
        [Header("Component Merging Options")]
        [Tooltip("If checked, attempts to normalize parent scales before merging to prevent 'exploding' meshes.")]
        public bool preventScaleDistortion = true;

        [Tooltip("Merge DynamicBone components")]
        public bool mergeDynamicBones = true;

        [Tooltip("Merge Magica Cloth components")]
        public bool mergeMagicaCloth = true;

        [Header("CVR Component Merging")]
        public bool mergeAdvancedAvatarSetup = true;
        public bool generateAASControllerAtEnd = true;
        public string advancedSettingsPrefix = "";
        public bool mergeAdvancedPointerTrigger = true;
        public bool mergeParameterStream = true;
        public bool mergeAnimatorDriver = true;

        [Header("Animator Merging (Master)")]
        [Tooltip("Master switch. If disabled, no animators are merged regardless of per-outfit settings.")]
        public bool mergeAnimator = true;

        // =======================
        // NEW GLOBAL OPTIONS
        // =======================

        [Header("Bone Matching (Global)")]
        [Tooltip("If exact name matching fails, try mapping list and/or Levenshtein fuzzy matching.")]
        public bool enableFuzzyBoneMatching = true;

        [Tooltip("Global mapping dictionary for bone names (after prefix/suffix stripping).")]
        public List<BoneNameMapping> globalBoneNameMappings = new List<BoneNameMapping>();

        [Tooltip("Enable Levenshtein fuzzy match if no mapping and no exact match.")]
        public bool enableLevenshteinBoneMatching = false;

        [Tooltip("Maximum Levenshtein distance allowed for fuzzy matching.")]
        [Range(1, 10)]
        public int maxLevenshteinDistance = 1;

        [Header("Animator Merging (Global Improvements)")]
        [Tooltip("Rewrite AnimationClip binding paths to match the merged hierarchy.")]
        public bool animatorRewritePaths = true;

        [Tooltip("If multiple incoming layers share the same original name, merge their AvatarMasks (union).")]
        public bool animatorMergeAvatarMasks = true;

        [Tooltip("Merge layers by original layer name instead of always creating unique (outfit-prefixed) layer names.")]
        public bool animatorCombineLayersByName = false;

        [Header("Broken Animator References")]
        public List<BrokenAnimatorReference> brokenReferences = new List<BrokenAnimatorReference>();

        public Component GetCVRAvatar()
        {
            var cvrAvatarType = FindCVRAvatarType();
            if (cvrAvatarType == null) return null;
            return GetComponent(cvrAvatarType);
        }

        private System.Type FindCVRAvatarType()
        {
            foreach (var assembly in System.AppDomain.CurrentDomain.GetAssemblies())
            {
                var type = assembly.GetType("ABI.CCK.Components.CVRAvatar");
                if (type != null) return type;
            }
            return null;
        }

        private void OnValidate()
        {
            if (GetCVRAvatar() == null && !Application.isPlaying)
            {
                Debug.LogWarning($"[CVR Merge Armature] This GameObject must have a CVRAvatar component!", this);
            }
        }

        public bool IsExcluded(Transform t)
        {
            if (excludedTransforms.Contains(t)) return true;
            foreach (var pattern in excludedNamePatterns)
            {
                if (MatchesPattern(t.name, pattern)) return true;
            }
            return false;
        }

        private bool MatchesPattern(string name, string pattern)
        {
            if (string.IsNullOrEmpty(pattern)) return false;
            try
            {
                return System.Text.RegularExpressions.Regex.IsMatch(
                    name,
                    "^" + System.Text.RegularExpressions.Regex.Escape(pattern)
                        .Replace("\\*", ".*")
                        .Replace("\\?", ".") + "$"
                );
            }
            catch { return false; }
        }
    }
}
